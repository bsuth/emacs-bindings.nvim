local
CORE_WORD_CHARS
=
{
_
=
true
,
}
for
byte
=
string
.byte(
'0'
)
,
string
.byte(
'9'
)
do
CORE_WORD_CHARS
[
string
.char(
byte
)
]
=
true
end
for
byte
=
string
.byte(
'a'
)
,
string
.byte(
'z'
)
do
CORE_WORD_CHARS
[
string
.char(
byte
)
]
=
true
end
for
byte
=
string
.byte(
'A'
)
,
string
.byte(
'Z'
)
do
CORE_WORD_CHARS
[
string
.char(
byte
)
]
=
true
end
local
function
getWordChars
()
local
wordChars
=
{
}
for
coreWordChar
in
pairs(
CORE_WORD_CHARS
)
do
wordChars
[
coreWordChar
]
=
true
end
for
i
=
1
,
#
vim
.g
.emacs_bindings_wordchars
do
wordChars
[
vim
.g
.emacs_bindings_wordchars
:sub(
i
,
i
)
]
=
true
end
return
wordChars
end
local
function
feedTermCodes
(termCodes)
vim
.api
.nvim_feedkeys(
vim
.api
.nvim_replace_termcodes(
termCodes
,
true
,
false
,
true
)
,
'n'
,
false
)
end
local
function
getWordBackCol
(line,col)
local
wordChars
=
getWordChars(
)
local
nextChar
=
line
:sub(
col
-
1
,
col
-
1
)
while
col
>
1
and
not
wordChars
[
nextChar
]
do
col
=
col
-
1
nextChar
=
line
:sub(
col
-
1
,
col
-
1
)
end
while
col
>
1
and
wordChars
[
nextChar
]
do
col
=
col
-
1
nextChar
=
line
:sub(
col
-
1
,
col
-
1
)
end
return
col
end
local
function
getMoveWordForwardCol
(line,col)
local
wordChars
=
getWordChars(
)
local
nextChar
=
line
:sub(
col
+
1
,
col
+
1
)
while
col
<
#
line
and
wordChars
[
nextChar
]
do
col
=
col
+
1
nextChar
=
line
:sub(
col
+
1
,
col
+
1
)
end
while
col
<
#
line
and
not
wordChars
[
nextChar
]
do
col
=
col
+
1
nextChar
=
line
:sub(
col
+
1
,
col
+
1
)
end
return
col
+
1
end
local
function
getDeleteWordForwardCol
(line,col)
local
wordChars
=
getWordChars(
)
local
nextChar
=
line
:sub(
col
+
1
,
col
+
1
)
while
col
<
#
line
and
not
wordChars
[
nextChar
]
do
col
=
col
+
1
nextChar
=
line
:sub(
col
+
1
,
col
+
1
)
end
while
col
<
#
line
and
wordChars
[
nextChar
]
do
col
=
col
+
1
nextChar
=
line
:sub(
col
+
1
,
col
+
1
)
end
return
col
+
1
end
local
function
moveWordBack
()
if
vim
.fn
.mode(
)
==
'c'
then
local
col
=
vim
.fn
.getcmdpos(
)
local
line
=
vim
.fn
.getcmdline(
)
feedTermCodes(
(
'<Left>'
)
:rep(
col
-
getWordBackCol(
line
,
col
)
)
)
else
local
__ERDE_TMP_13__
=
vim
.fn
.getpos(
'.'
)
local _ = __ERDE_TMP_13__[1]
local lnum = __ERDE_TMP_13__[2]
local col = __ERDE_TMP_13__[3]
local
line
=
vim
.fn
.getline(
'.'
)
vim
.fn
.setcharpos(
'.'
,
{
0
,
lnum
,
getWordBackCol(
line
,
col
)
,
0
,
}
)
end
end
local
function
moveWordForward
()
if
vim
.fn
.mode(
)
==
'c'
then
local
col
=
vim
.fn
.getcmdpos(
)
local
line
=
vim
.fn
.getcmdline(
)
feedTermCodes(
(
'<Right>'
)
:rep(
getMoveWordForwardCol(
line
,
col
)
-
col
)
)
else
local
__ERDE_TMP_14__
=
vim
.fn
.getpos(
'.'
)
local _ = __ERDE_TMP_14__[1]
local lnum = __ERDE_TMP_14__[2]
local col = __ERDE_TMP_14__[3]
local
line
=
vim
.fn
.getline(
'.'
)
vim
.fn
.setcharpos(
'.'
,
{
0
,
lnum
,
getMoveWordForwardCol(
line
,
col
)
,
0
,
}
)
end
end
local
function
deleteCharBack
()
local
__ERDE_TMP_15__
=
vim
.fn
.getpos(
'.'
)
local _ = __ERDE_TMP_15__[1]
local _ = __ERDE_TMP_15__[2]
local col = __ERDE_TMP_15__[3]
if
vim
.fn
.mode(
)
==
'c'
or
col
>
1
then
feedTermCodes(
'<BS>'
)
end
end
local
function
deleteCharForward
()
local
__ERDE_TMP_16__
=
vim
.fn
.getpos(
'.'
)
local _ = __ERDE_TMP_16__[1]
local _ = __ERDE_TMP_16__[2]
local col = __ERDE_TMP_16__[3]
local
line
=
vim
.fn
.getline(
'.'
)
if
vim
.fn
.mode(
)
==
'c'
or
col
<=
#
line
then
feedTermCodes(
'<Delete>'
)
end
end
local
function
deleteWordBack
()
if
vim
.fn
.mode(
)
==
'c'
then
local
col
=
vim
.fn
.getcmdpos(
)
local
line
=
vim
.fn
.getcmdline(
)
feedTermCodes(
(
'<BS>'
)
:rep(
col
-
getWordBackCol(
line
,
col
)
)
)
else
local
__ERDE_TMP_17__
=
vim
.fn
.getpos(
'.'
)
local _ = __ERDE_TMP_17__[1]
local lnum = __ERDE_TMP_17__[2]
local col = __ERDE_TMP_17__[3]
local
line
=
vim
.fn
.getline(
'.'
)
local
newCol
=
getWordBackCol(
line
,
col
)
vim
.fn
.setline(
lnum
,
line
:sub(
1
,
newCol
-
1
)
..
line
:sub(
col
)
)
vim
.fn
.setcharpos(
'.'
,
{
0
,
lnum
,
newCol
,
0
,
}
)
end
end
local
function
deleteWordForward
()
if
vim
.fn
.mode(
)
==
'c'
then
local
col
=
vim
.fn
.getcmdpos(
)
local
line
=
vim
.fn
.getcmdline(
)
feedTermCodes(
(
'<Delete>'
)
:rep(
getDeleteWordForwardCol(
line
,
col
)
-
col
)
)
else
local
__ERDE_TMP_18__
=
vim
.fn
.getpos(
'.'
)
local _ = __ERDE_TMP_18__[1]
local lnum = __ERDE_TMP_18__[2]
local col = __ERDE_TMP_18__[3]
local
line
=
vim
.fn
.getline(
'.'
)
local
newCol
=
getDeleteWordForwardCol(
line
,
col
)
vim
.fn
.setline(
lnum
,
line
:sub(
1
,
col
-
1
)
..
line
:sub(
newCol
)
)
end
end
local
function
deleteLineBack
()
if
vim
.fn
.mode(
)
==
'c'
then
feedTermCodes(
(
'<BS>'
)
:rep(
vim
.fn
.getcmdpos(
)
)
)
else
local
__ERDE_TMP_19__
=
vim
.fn
.getpos(
'.'
)
local _ = __ERDE_TMP_19__[1]
local lnum = __ERDE_TMP_19__[2]
local col = __ERDE_TMP_19__[3]
local
line
=
vim
.fn
.getline(
'.'
)
vim
.fn
.setline(
lnum
,
line
:sub(
col
)
)
vim
.fn
.setcharpos(
'.'
,
{
0
,
lnum
,
1
,
0
,
}
)
end
end
local
function
deleteLineForward
()
if
vim
.fn
.mode(
)
==
'c'
then
local
col
=
vim
.fn
.getcmdpos(
)
local
line
=
vim
.fn
.getcmdline(
)
feedTermCodes(
(
'<Delete>'
)
:rep(
#
line
-
col
+
1
)
)
else
local
__ERDE_TMP_20__
=
vim
.fn
.getpos(
'.'
)
local _ = __ERDE_TMP_20__[1]
local lnum = __ERDE_TMP_20__[2]
local col = __ERDE_TMP_20__[3]
local
line
=
vim
.fn
.getline(
'.'
)
vim
.fn
.setline(
lnum
,
line
:sub(
1
,
col
-
1
)
)
end
end
return { moveWordBack=moveWordBack,moveWordForward=moveWordForward,deleteCharBack=deleteCharBack,deleteCharForward=deleteCharForward,deleteWordBack=deleteWordBack,deleteWordForward=deleteWordForward,deleteLineBack=deleteLineBack,deleteLineForward=deleteLineForward }
-- __ERDE_COMPILED__